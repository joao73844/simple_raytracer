#include "Sphere.h"


// Default Constructor
/// Creates a Grey Sphere in the origin with radius 1
Sphere::Sphere() {
	_center = Vect(0, 0, 0);
	_radius = 1.0;
	_color = Color(0.5, 0.5, 0.5, 0);
}
// General Constructor
Sphere::Sphere(Vect center, double radius, Color color) {
	_center = center;
	_radius = radius;
	_color = color;
}


Sphere::~Sphere()
{
}

double Sphere::findIntersection(Ray ray) {
	// use the TUTORIAL (CALEB PERCY) Algorithmn
	/// Vector and Coordinates of the Origin of the Ray
	/// This is just for the sake of legibility
	Vect ray_origin = ray.getRayOrigin();
	double ray_origin_x = ray_origin.getX();
	double ray_origin_y = ray_origin.getY();
	double ray_origin_z = ray_origin.getZ();
	/// Vector and Coordinates of the Direction of the Ray
	/// This is just for the sake of legibility
	Vect ray_direction = ray.getRayDirection().normalize();
	double ray_direction_x = ray_direction.getX();
	double ray_direction_y = ray_direction.getY();
	double ray_direction_z = ray_direction.getZ();
	/// Vector and Coordinates of the Sphere Center
	/// This is just for the sake of legibility
	Vect sphere_center = _center;
	double sphere_center_x = sphere_center.getX();
	double sphere_center_y = sphere_center.getY();
	double sphere_center_z = sphere_center.getZ();

	double a = 1.0; /// normalized
	double b = (2 * (ray_origin_x - sphere_center_x) * ray_direction_x) +
		(2 * (ray_origin_y - sphere_center_y) * ray_direction_y) +
		(2 * (ray_origin_z - sphere_center_z) * ray_direction_z);
	/// @variable c is the difference between
	/// the distance from the center of the ray to the center of the sphere (squared)
	/// and the ray (squared)
	/// so if the number is zero it means that the ray came from
	/// THE SPHERE SURFACE, as it the same length as the radius
	/// if its a negative number it means the ray came from INSIDE THE SPHERE
	/// if its a positive number it means the ray came from OUTSIDE THE SPHERE
	double c = pow(ray_origin_x - sphere_center_x, 2) +
		pow(ray_origin_y - sphere_center_y, 2) +
		pow(ray_origin_z - sphere_center_z, 2);
	/// @variable (missing the discription...)
	double discriminant = b*b - 4 * c;

	if (discriminant > 0) {
		/// the ray intersects the sphere

		/// the first root
		double	root_1 = ((-1 * b - sqrt(discriminant)) / 2) - _ACCURACY_ERROR_EPSILON_;

		if (root_1 > 0) {
			/// The first root is the smallest positive root
			return root_1;
		}
		else {
			/// the second root is the smallest positive root
			double root_2 = ((-1 * b + sqrt(discriminant)) / 2) - _ACCURACY_ERROR_EPSILON_;
			return root_2;
		}
	}
	else {
		/// the ray missed the sphere
		return -1.0;
	}
	return 0.0;
}

// WARNING
/// DO NOT USE THIS METHOD !!!!!!!!!!!!!
IntersectionPoint Sphere::findIntersection_2(Ray ray) {
	// USING THE CLASS ALGORITHMN
	
	// INITIALIZATIONS
	/// Vector and Coordinates of the Origin of the Ray
	/// This is just for the sake of legibility
	Vect ray_origin = ray.getRayOrigin();
	double ray_origin_x = ray_origin.getX();
	double ray_origin_y = ray_origin.getY();
	double ray_origin_z = ray_origin.getZ();
	/// Vector and Coordinates of the Direction of the Ray
	/// This is just for the sake of legibility
	Vect ray_direction = ray.getRayDirection().normalize();
	double ray_direction_x = ray_direction.getX();
	double ray_direction_y = ray_direction.getY();
	double ray_direction_z = ray_direction.getZ();
	/// Vector and Coordinates of the Sphere Center
	/// This is just for the sake of legibility
	Vect sphere_center = _center;
	double sphere_center_x = sphere_center.getX();
	double sphere_center_y = sphere_center.getY();
	double sphere_center_z = sphere_center.getZ();


	// Step 1 - Normalize ray_direction
	/// already done!!
	// Step 2 - Compute the squared distance from the Ray Origin(O) to the Sphere Center(C)
	/// Compute vector OC (vector from O to C)
	double OC_x = sphere_center_x - ray_origin_x;
	double OC_y = sphere_center_y - ray_origin_y;
	double OC_z = sphere_center_z - ray_origin_z;
	Vect OC(OC_x, OC_y, OC_z);
	double distance_OC_squared = OC.dotProduct(OC);
	// Step 3 - Compare the magnitude of distance_OC with the Sphere radius
	/// IF the magnitude equals the radius it means the ray came from
	/// the sphere surface, so we consider that it doesn't itersect
	/// IF its smaller than the radius then the ray came from INSIDE
	/// the sphere, so we will also consider it doesn't intersect
	double sphere_radius_squared = _radius * _radius;
	double C = distance_OC_squared - sphere_radius_squared;
	if (C == 0) return IntersectionPoint(Vect(),Vect());
	// Step 4 - Compute the B of the quadratic equation
	// generated by ray_direction dot product with OC
	double B = ray_direction.dotProduct(OC);
	// Step 5 - Check if the ray is in the opposite direction of the sphere
	/// If TRUE, it means that the RAY is pointing in the opposite
	/// direction of the SPHERE Center, so it won't intersect
	if (C > 0.0 && B < 0.0) return IntersectionPoint(Vect(), Vect());
	// Step 6 - Compute discriminant (B*B-C)
	/// If the discriminant is negative and it will generate a complex
	/// number, which means that the Ray missed the Sphere
	double discriminant = (B*B) - C;
	if (discriminant < 0.0) return IntersectionPoint(Vect(), Vect());
	// Step 7 - Compute the Roots (T) of the equation
	double T = 0.0;
	if (distance_OC_squared > sphere_radius_squared) {
		/// The negative root is the nearest one
		T = B - sqrt(discriminant);
	}
	else {
		/// The positive root is the nearest one
		T = B + sqrt(discriminant);
	}
	// Step 8 - Compute the intersection point (R)
	double R_x = ray_origin_x + ray_direction_x*T + _ACCURACY_ERROR_EPSILON_;
	double R_y = ray_origin_y + ray_direction_y*T + _ACCURACY_ERROR_EPSILON_;
	double R_z = ray_origin_z + ray_direction_z*T + _ACCURACY_ERROR_EPSILON_;
	Vect R(R_x, R_y, R_z);
	// Step 9 - Compute the normal to the Sphere surface and the intersection point (R)
	double N_x = (R_x - sphere_center_x) / _radius;
	double N_y = (R_y - sphere_center_y) / _radius;
	double N_z = (R_z - sphere_center_z) / _radius;
	
	if (distance_OC_squared < sphere_radius_squared) {
		/// It means the ray came from INSIDE the sphere so the Normal is inverted
		Vect N(-1 * N_x, -1 * N_y, -1 * N_z);
		return IntersectionPoint(R, N);
	}

	Vect N(N_x, N_y, N_z);
	return IntersectionPoint(R, N);
}